//This file contains the main functions to maximise the order locally at an unramified place given by a field element f.
import "invariants.m":GlobalPlace,LocalSubDegree,IntegralClosureRing,FixDenominator;
//import "util.m":EchelonBasis;

//returns m and n such that f^m*(\tau^u)^n is maximal order of skewfield of order d^2
MaximizeDivAlg := function(a,f,d,F)
  v := GlobalPlace(F,f);
  va := Valuation(a,v);
  _,m,n := Xgcd(d,va);
  return m, n;
end function;

//utility to lift a local basis, given by Is (order ideals generated by the basis elements)
LiftLocalBasis := function(Is,O,L,d,u,i)
  k,psi := ResidueClassField(Is[i]);
  alpha := PrimitiveElement(k);
  prod := Is[i]^0;
  for k := 1 to u do
      if k ne i then
	prod *:= Is[k];
      end if;
  end for;
  
  b := [];
  for j := 1 to d do
    x := ((alpha^(j)) @@ psi);
    x := CRT(Is[i], prod, x, O!0);
    Append(~b,L!x);
  end for;
  return b;
end function;

//main function to maximise order at unramified place given by f by direct formula
intrinsic MaximizeUnramified(f::RngElt,L::Fld,sigma::Map,a::RngElt,pi_F::RngElt)
-> Mtrx
{}
  A:=Parent(a); F:=FieldOfFractions(A); O:=IntegralClosureRing(A,L);
  r := Degree(L);
  print "Computing ramification place";
  w := GlobalPlace(F, pi_F);
  
  d := LocalSubDegree(F!f,w,r); u := r div d;
  m,n := MaximizeDivAlg(a,f,d,F);
  B := BasisMatrix(O)^-1;
  
  p := GlobalPlace(F, f);
  Is := [];
  I := Factorization(f*O)[1][1];
  for j:= 1 to u do
    Append(~Is, I);
    gs := Generators(I);
    for i := 1 to #gs do
      gs[i] := sigma(gs[i]);
    end for;
    I := ideal<O|gs>;
  end for;
  
  bs := ZeroMatrix(L, u, d);
  for i := 1 to u do
    b := LiftLocalBasis(Is,O,L,d,u,i);
    bs[i] := Vector(b);
  end for;
  es := [F!-1000: i in [1..d+1]];
  for i := 0 to d-1 do
    exp := n*i;
    fc := F!f^(m*i);
    ac := F!a^(exp div d);
    es[exp mod d +1] := fc*ac;
  end for;
  es[d+1] := F!f^(-Valuation(a, GlobalPlace(F,f)));
  M := IdentityMatrix(F, r^2);
  N := ZeroMatrix(F, d*r^2, r^2);
  for i := 0 to d-1 do
    for j := 1 to r do
      for k := 0 to r-1 do
	exp := i*u+k;
	N[i*r^2+k*r+j][(exp mod r)*r+j] := es[i+1]*F!a^(exp div r);
      end for;
    end for;
  end for;
  exps := [Integers()|];
  facs := [L|];
  for j := 1 to u do
    for jp := j+1 to u do
      for s := 1 to d do
	for t := 1 to d do
	    exp := (jp-1)+(u*(s-1));
	    Append(~exps, exp);
	    Append(~facs, bs[j][t]*es[s+1]);
	end for;
      end for;
    end for;
  end for;
  R := ZeroMatrix(F, #exps, r^2);
  for i := 1 to #exps do
      seq := Eltseq(L!(facs[i]));
      seq := Vector(seq)*B;
      for k := 1 to r do
 	R[i][exps[i]*r+k] := seq[k];
      end for;
  end for;
  lambda_v := VerticalJoin(VerticalJoin(M,N),R);
  
  print "Fixing Denominator";
  lambda_v := FixDenominator(lambda_v, f, F);
  print "Computing echelon form";
  lambda_v := EchelonBasis(lambda_v, A);
  
  return lambda_v;
end intrinsic;