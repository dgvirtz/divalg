//This file contains the main functions to maximise the order locally at an unramified place given by a field element f.

//returns m and n such that f^m*(\tau^u)^n is maximal order of skewfield of order d^2
MaximizeDivAlg := function(a,f,d,F)
  v := GlobalPlace(F,f);
  va := Valuation(a,v);
  _,m,n := Xgcd(d,va);
  return m, n;
end function;

//utility to lift a local basis, given by Is (order ideals generated by the basis elements)
LiftLocalBasis := function(Is,O,L,d,u,i)
  k,psi := ResidueClassField(Is[i]);
  alpha := PrimitiveElement(k);
  prod := Is[i]^0;
  for k := 1 to u do
      if k ne i then
	prod *:= Is[k];
      end if;
  end for;
  
  b := [];
  for j := 1 to d do
    x := ((alpha^(j)) @@ psi);
    x := CRT(Is[i], prod, x, O!0);
    Append(~b,L!x);
  end for;
  return b;
end function;

//main function to maximise order at unramified place by direct formula
MaximizeUnramified := function(f,w,r,O,L,F,A,sigma,a)
  d := LocalSubDegree(F!f,w,r); u := r div d;
  m,n := MaximizeDivAlg(a,f,d,F);
  B := BasisMatrix(O)^-1;
  
  p := GlobalPlace(F, f);
  Is := [];
  I := Factorization(f*O)[1][1];
  for j:= 1 to u do
    Append(~Is, I);
    gs := Generators(I);
    for i := 1 to #gs do
      gs[i] := sigma(gs[i]);
    end for;
    I := ideal<O|gs>;
  end for;
  
  bs := ZeroMatrix(L, u, d);
  for i := 1 to u do
    b := LiftLocalBasis(Is,O,L,d,u,i);
    bs[i] := Vector(b);
  end for;
  es := [F!-1000: i in [1..d+1]];
  for i := 0 to d-1 do
    exp := n*i;
    fc := f^(m*i);
    ac := a^(exp div d);
    es[exp mod d +1] := fc*ac;
  end for;
  es[d+1] := f^(-Valuation(a, GlobalPlace(F,f)));
  M := IdentityMatrix(F, r^2);
  N := ZeroMatrix(F, d*r^2, r^2);
  for i := 0 to d-1 do
    for j := 1 to r do
      for k := 0 to r-1 do
	exp := i*u+k;
	N[i*r^2+k*r+j][(exp mod r)*r+j] := es[i+1]*a^(exp div r);
      end for;
    end for;
  end for;
  exps := [Integers()|];
  facs := [L|];
  for j := 1 to u do
    for jp := j+1 to u do
      for s := 1 to d do
	for t := 1 to d do
	    exp := (jp-1)+(u*(s-1));
	    Append(~exps, exp);
	    Append(~facs, bs[j][t]*es[s+1]);
	end for;
      end for;
    end for;
  end for;
  R := ZeroMatrix(F, #exps, r^2);
  for i := 1 to #exps do
      seq := Eltseq(L!(facs[i]));
      seq := Vector(seq)*B;
      for k := 1 to r do
 	R[i][exps[i]*r+k] := seq[k];
      end for;
  end for;
  return VerticalJoin(VerticalJoin(M,N),R);
end function;